---
layout: post
title:  "Introducing `posh`: Type-Safe Graphics Programming in Rust"
date:   2023-05-21 17:00:00 +0100
categories: rust gamedev posh
---

This post introduces [`posh`](https://github.com/leod/posh), an experimental Rust graphics library aimed at enhancing the type-safety, composability, and overall experience of graphics programming.
The post covers the fundamental concepts of `posh`, showcases examples, discusses related work and limitations of the approach, and, for readers who might be interested in details, delves into the internal workings of the library.

`posh` consists of two closely integrated modules: `posh::gl`, a graphics library responsible for uploading data to the GPU and executing draw calls, and `posh::sl`, a functional shading language embedded within Rust.
The tight integration between these modules enables static verification, ensuring that the data provided in draw calls aligns with the shader's signature.

The typical structure of `posh` code follows this pattern:
```rust
use posh::{gl, sl};

// ... define custom shader interface types U, V, W, and F ...

fn vertex_shader(uniform: U, vertex: V) -> sl::VsOutput<W> {
    // ... compute `sl::VsOutput { clip_position, interpolant }` ...
}

fn fragment_shader(uniform: U, interpolant: W) -> F {
    // ... compute F ...
}

let program: gl::Program<U, V, F> = gl.create_program(
    vertex_shader,
    fragment_shader,
)?;

program
    .with_uniforms(/* uniform bindings matching U */)
    .with_framebuffer(/* framebuffer matching F */)
    .with_settings(/* draw settings */)
    .draw(/* vertex specification matching V */)?;
```
Shader functions are written as Rust code that interacts with types from `posh::sl`, thereby leveraging the benefits of Rust's type checking and composability.
Internally, at runtime, shader functions generate expression graphs that are translated to GLSL.
Since these are regular Rust functions, their signatures naturally become part of the `program`'s type, ensuring type safety when invoking the `draw` method.

The development of `posh` is motivated by the aim to simplify and streamline graphics programming.
Traditional graphics code often involves two distinct languages: the host language (e.g., Rust) and the shading language (e.g., GLSL).
This separation leads to boilerplate code on both sides and hampers the composition of functionality.
Moreover, draw calls, which act as a foreign function interface from host code to shader code, typically lack static type checks.
To address these challenges, `posh` provides a platform for defining shaders using a functional language embedded within Rust and integrates shader signatures with the graphics library.

## Table of Contents

* TOC
{:toc}

## Current Status

Currently, in order to narrow down the initial scope of the project, `posh` targets subsets of [OpenGL ES 3.0](https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf) and [GLSL ES 3.0](https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf).
However, we are considering to transition to [wgpu](https://github.com/gfx-rs/wgpu) in the long run.

It is important to note that `posh` is still in its early stages and may require several revisions to reach stabilization.
We welcome contributions to the design and implementation. Feel free to explore `posh`'s [repository](https://github.com/leod/posh), including its [examples](https://github.com/leod/posh/tree/main/examples) and [open issues](https://github.com/leod/posh/issues), to get an idea of where we currently stand.
Please be aware that there is no release available on [crates.io](https://crates.io/) at this time.

## A Basic Example: Hello, Triangle!

![Example: A triangle](/assets/hello_triangle.png)

To get started, let us draw a triangle whose position and shading depend on the current time.
You can find the complete source code for this example in the [repository](https://github.com/leod/posh/blob/main/examples/hello_triangle.rs).

When writing `posh` code, there are three basic steps to follow.

### 1) Define Shader Interface Types

Shaders typically require access to uniform inputs provided by the host.
In this example, we will need the current time and the desired size of the triangle.
To achieve this, we create a struct and derive `Block` for it, which allows us to use it as a uniform block.
```rust
use posh::{Block, BlockDom};

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct Globals<D: BlockDom> {
    time: D::F32,
    size: D::Vec2,
}
```

Shader interface types like `Globals<D>` are generic in the domain `D`.
There are two domains: `posh::Gl`, which provides data and bindings for draw calls, and `posh::Sl`, which provides types used in shader definitions.
The concept of domains connects the two sides of graphics programming.
We'll use `Globals<Gl>` to describe data to be stored in buffers on the GPU and `Globals<Sl>` to access inputs in our shader code.

### 2) Write Shader Code

Next, we will write shader code using `posh::sl`.
We will define the vertex shader and the fragment shader functions to specify where and how the triangle should be drawn.

In `posh::sl`, shader functions have two arguments.
The first argument is the uniform input, while the second argument is the current input of the shader (vertex input for the vertex shader and interpolant input for the fragment shader).

In this example, the vertex shader receives `Globals<Sl>` as uniform input, and a two-dimensional position as vertex input.
The shader computes the `clip_position` output (equivalent to `gl_Position` in GLSL) along with an `interpolant`, which is interpolated and passed on to the fragment shader by the GPU:
```rust
use posh::{sl, Sl};

fn vertex_shader(
    globals: Globals<Sl>,
    vertex: sl::Vec2,
) -> sl::VsOutput<sl::Vec2> {
    let position = sl::Vec2::from_angle(globals.time)
        .rotate(vertex * globals.size);

    sl::VsOutput {
        clip_position: sl::vec4(position.x, position.y, 0.0, 1.0),
        interpolant: vertex,
    }
}

```

The fragment shader uses the `interpolant` to compute a time-dependent color for each fragment:
```rust
fn fragment_shader(globals: Globals<Sl>, interpolant: sl::Vec2) -> sl::Vec4 {
    let rg = (interpolant + globals.time).cos().powf(2.0);

    sl::vec4(rg.x, rg.y, 0.5, 1.0)
}
```

Internally, types like `Globals<Sl>` or `sl::Vec2` represent expression graphs that can be transformed to GLSL.
For instance, the variables `globals` and `interpolant` are leaf nodes representing inputs of the fragment shader.
Expressions like `interpolant + globals.time` are nodes in the expression graph that describe how their values are computed.
This makes it possible to transpile `vertex_shader` and `fragment_shader` as a whole to GLSL without requiring macro magic.

### 3) Write Host Code

Now, we will write host code using `posh::gl`.
We will set up buffer data on the GPU and then perform a draw call with the shader that we have defined above.
For the purpose of this example, we will assume that we already have a variable `gl: gl::Context` available (ignoring context creation).

First, we compile our two shader functions into a program.
Note that the program's type carries the shader's signature:
```rust
use posh::gl;

let program: gl::Program<Globals<Sl>, sl::Vec2> = gl.create_program(
    vertex_shader,
    fragment_shader,
)?;
```

Next, we set up buffers on the GPU to hold data to be supplied to the shader.
The types of `globals` and `vertices` align with the signature of the `program`:
```rust
let globals: gl::UniformBuffer<Globals<Gl>> = gl.create_uniform_buffer(
    Globals {
        time: 42.0,
        size: [1.0, 1.0].into(),
    },
    gl::BufferUsage::StreamDraw,
)?;

let vertices: gl::VertexBuffer<gl::Vec2> = gl.create_vertex_buffer(
    &[
        [0.0f32, 1.0].into(),
        [-0.5, -0.5].into(),
        [0.5, -0.5].into(),
    ],
    gl::BufferUsage::StreamDraw,
)?;
```

Finally, we perform a draw call using a method of `program`.
This requires us to supply bindings for uniform inputs and vertex inputs, along with various draw settings.
```rust
program
    .with_uniforms(globals.as_binding())
    .with_settings(
        gl::DrawSettings::default()
            .with_clear_color([0.1, 0.2, 0.3, 1.0])
    )
    .draw(vertices.as_vertex_spec(gl::PrimitiveMode::Triangles))?;
```

The draw call is where everything comes together in `posh`.
It takes our compiled shader, supplies GPU buffer bindings, and draws something to a framebuffer (in this instance, the default framebuffer).
The `draw` method benefits from static type-checking, allowing the Rust compiler to help ensure that the data we provide matches the expected types in the shader.
This provides an additional level of correctness to our graphics programming workflow.

## A More Complex Example: Shadow Mapping

![Example: Shadow Mapping](/assets/shadow_map.png)

In this section, we will a explore a more complex example.
We will look at a way to render a scene with [shadow mapping](https://en.wikipedia.org/wiki/Shadow_mapping) (assuming that the shadow map has already been created).
You can find the complete source code for this example in the [repository](https://github.com/leod/posh/blob/main/examples/shadow_map.rs).

Without delving into details of how shadow mapping works, let us again follow the three basic steps of writing `posh` code.

### 1) Define Shader Interface Types

First, we define a custom vertex type, `SceneVertex<D>`, to hold world-space information of the scene to be drawn.
We also define the `Camera<D>` and `Light<D>` types for the view camera and the light source.
```rust
use posh::{Block, BlockDom};

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct SceneVertex<D: BlockDom> {
    world_pos: D::Vec3,
    world_normal: D::Vec3,
    color: D::Vec3,
}

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct Camera<D: BlockDom> {
    world_to_eye: D::Mat4,
    eye_to_clip: D::Mat4,
}

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct Light<D: BlockDom> {
    camera: Camera<D>,
    world_pos: D::Vec3,
    color: D::Vec3,
    ambient: D::Vec3,
}
```

Lastly, we define the `SceneUniforms<D>` type, which encapsulates the uniform inputs required by our shaders, including the depth map sampler.

```rust
use posh::{UniformInterface, UniformInterfaceDom};

#[derive(Clone, UniformInterface)]
struct SceneUniforms<D: UniformInterfaceDom> {
    camera: D::Block<Camera<Sl>>,
    light: D::Block<Light<Sl>>,
    light_depth_map: D::ComparisonSampler2d,
}
```

Any type that implements `UniformInterface` can be used as uniform input for shaders.
Similar to `Block` declarations, `UniformInterface` declarations are generic in the domain `D`.
In this example, `SceneUniforms<Gl>` contains bindings of uniform buffers and samplers, while `SceneUniforms<Sl>` provides the inputs for shader definitions.

### 2) Write Shader Code

Next, let us define an `Interpolant` struct, which connects the vertex and fragment shaders.
The fragment shader requires access to the interpolated input vertex and the input vertex's position in the light source's clip space.
```rust
use posh::{sl, Sl};

#[derive(Clone, Copy, sl::Value, sl::Interpolant)]
struct Interpolant {
    vertex: SceneVertex<Sl>,
    light_clip_pos: sl::Vec4,
}
```

Now, we can implement our vertex shader, using a utility function for `Camera<Sl>`:
```rust
impl Camera<Sl> {
    fn world_to_clip(self, world_pos: sl::Vec3) -> sl::Vec4 {
        self.eye_to_clip * self.world_to_eye * world_pos.extend(1.0)
    }
}

fn vertex_shader(
    SceneUniforms { light, camera, .. }: SceneUniforms<Sl>,
    vertex: SceneVertex<Sl>,
) -> sl::VsOutput<Interpolant> {
    // Slightly extrude along the normal to reduce shadow artifacts.
    const EXTRUDE: f32 = 0.1;
    let light_clip_pos = light
        .camera
        .world_to_clip(vertex.world_pos + vertex.world_normal * EXTRUDE);

    sl::VsOutput {
        clip_position: camera.world_to_clip(vertex.world_pos),
        interpolant: Interpolant { vertex, light_clip_pos },
    }
}
```

The `Interpolant` is fed from the vertex shader to the fragment shader, which uses it to sample the shadow map and shade the fragment.

```rust
fn sample_shadow(
    light_depth_map: sl::ComparisonSampler2d,
    light_clip_pos: sl::Vec4,
) -> sl::F32 {
    let ndc = light_clip_pos.xyz() / light_clip_pos.w;
    let uvw = ndc * 0.5 + 0.5;

    // Fall back to zero if the UV coordinates would be clamped.
    let clamp = sl::any([
        uvw.x.lt(0.0),
        uvw.x.gt(1.0),
        uvw.y.lt(0.0),
        uvw.y.gt(1.0),
    ]);

    sl::branch(
        clamp,
        0.0,
        light_depth_map.sample_compare(uvw.xy(), uvw.z),
    )
}

fn fragment_shader(
    SceneUniforms { light, light_depth_map, ..  }: SceneUniforms<Sl>,
    Interpolant { vertex, light_clip_pos }: Interpolant,
) -> sl::Vec4 {
    let light_dir = (light.world_pos - vertex.world_pos).normalize();
    let diffuse = light.color * vertex.world_normal.dot(light_dir).max(0.0);
    let shadow = sample_shadow(light_depth_map, light_clip_pos);
    let color = (light.ambient + shadow * diffuse) * vertex.color;

    color.extend(1.0)
}
```

### 3) Write Host Code

On the host side, we compile the two shader functions into a program:
```rust
use posh::gl;

let program: gl::Program<SceneUniforms<Sl>, SceneVertex<Sl>> =
    gl.create_program(vertex_shader, fragment_shader)?;
```

We also need to set up several GPU buffers.
Ignoring the contents of the buffers, we have the following objects:
```rust
let camera_buffer: gl::UniformBuffer<Camera<Gl>> = todo!();
let light_buffer: gl::UniformBuffer<Light<Gl>> = todo!();
let light_depth_map: gl::DepthTexture2d = todo!();
let scene_vertices: gl::VertexBuffer<SceneVertex<Gl>> = todo!();
let scene_elements: gl::ElementBuffer = todo!();
```

Finally, we can render the scene with shadow mapping:
```rust
scene_program
    .with_uniforms(SceneUniforms {
        camera: camera_buffer.as_binding(),
        light: light_buffer.as_binding(),
        light_depth_map: light_depth_map.as_comparison_sampler(
            gl::Sampler2dSettings::linear(),
            gl::Comparison::Less,
        ),
    })
    .with_settings(
        gl::DrawSettings::default()
            .with_clear_color([1.0, 1.0, 1.0, 1.0].into())
            .with_clear_depth(2.0)
            .with_depth_test(gl::Comparison::Less)
            .with_cull_face(gl::CullFace::Back)
    )
    .draw(
        scene_vertices
            .as_vertex_spec(gl::PrimitiveMode::Triangles)
            .with_element_data(scene_elements.as_binding())
    )?;
```

Once again, the draw call serves as the point where all the components come together in a type-safe manner.
In the `with_uniforms` call, we provide uniform bindings of type `SceneUniforms<Gl>`, and in the subsequent `draw` call, we supply a vertex buffer of type `SceneVertex<Gl>`.
These types precisely match the expected `SceneUniforms<Sl>` and `SceneVertex<Sl>` types in the program's signature.

## Related Work

The development of `posh` has drawn inspiration from several amazing existing projects.

[`rust-gpu`](https://github.com/EmbarkStudios/rust-gpu) enables Rust to be used as a first-class language for writing shaders by implementing a `rustc` backend that generates [SPIR-V](https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation).
While `posh` shares the goal of enhancing shader development, it takes a different approach.
Instead of treating Rust as a primary shading language, `posh` employs a functional language embedded within Rust to implement shaders.
Additionally, while `rust-gpu` primarily focuses on shader code, `posh` places emphasis on achieving a type-safe integration between shader code and host code.

[Shades](https://github.com/phaazon/shades) provides an embedded domain-specific language for shaders, similar to `posh`.
However, Shades is designed as a general-purpose library without specific ties to a target shading language or graphics library.
In contrast, `posh` intentionally narrows its scope to a functional subset of GLSL and aligns itselfs with a subset of OpenGL.
We hope that this limitation will allow us to iterate quickly and focus on the integration of shader code with host code.
However, as a result, `posh` is less powerful than Shades in many ways.

[glium](https://github.com/glium/glium) is an OpenGL wrapper that demonstrates that OpenGL can be used elegantly in Rust.
In glium, the dependencies of a draw call are consolidated into a single method.
`posh` builds upon this concept by introducing typed shader signatures.

## Discussion

I have been dogfooding `posh` for a WebGL2-based game project and, after many iterations on the library, the experience has become quite pleasant to me.
While there certainly are rough edges, I am finding myself actually enjoying the process of writing shaders and making draw calls with them.

However, without doubt, the approach taken by `posh` has disadvantages.
It will be possible to address some of these, or reduce their impact, but other disadvantages are inherent to the approach.
1. Writing shader code is not quite like writing normal Rust code.
   For example, since shader functions are evaluated at shader compile-time (which happens at the host program's runtime!), the Rust `if` expression is actually a shader compile-time branch; users need to become familiar with this concept, and use `sl::branch` for dynamic branches.
2. Optimizing shader code may require users to build a mental model of how shaders are transpiled into GLSL.
3. Certain usage patterns cause redundant GLSL to be generated (see also [issue #96](https://github.com/leod/posh/issues/96)).
   In particular, making a function call in shader code (such as the call to `sample_shadow` in the earlier example) inlines the result of the function in the generated GLSL code.
   If a function is called twice, it is also inlined twice.
   In an earlier prototype, we had a procedural macro `#[posh::define_function]` that could be attached to functions so that they are also defined in GLSL.
   However, while the transformation performed by the macro was simple, it still introduced cognitive overhead when reading shader code.
4. The shading language does not offer mutable variables.
5. There is some trickery required to make values in the shading language `Copy`.
   See the section below for more detail on this.
6. The types of the bindings provided in host code need to match the shader signature precisely. There is no concept of allowing the binding of supersets of the data required by the shader signature.
7. Finally, this is a lot to take in just to write some graphics code!
   I've become familiar with it, and now feel empowered by it, but I'm not sure if it will be easy for others to get into it.

Overall, I remain confident that there is value in this integrated approach to graphics programming.
There may be better ways of getting there than the one currently taken by `posh`.
In my opinion, the key to making this work is to make the behavior of the library transparent to the user, i.e. to contain the magic parts to just a few places.

This domain feels underexplored, and I hope that `posh` can serve as inspiration for further investigations.

## How Does it Work?

`posh` utilizes Rust's powerful trait system and provides several traits and derive macros to establish the integration between the `posh::gl` graphics library and the `posh::sl` shading language.

This section delves into some implementation details of posh and explores the underlying mechanisms that enable interoperability between the two modules.
It is intended for readers who are interested in understanding the inner workings of posh.
However, it is worth noting that posh can be used effectively without a deep understanding of implementation details.

### Shader Interface Traits

The core of `posh`'s integration lies in the concept of shader interfaces, which are defined through traits.
These traits enable types to be used in shader signatures, allowing for type-safe interactions between the host code and the shaders.

The following traits play a crucial role in `posh`:
- `UniformInterface<D>`: Allows a type to be used as a uniform input in shaders.
- `VsInterface<D>`: Represents the vertex shader input interface. 
- `FsInterface<D>`: Represents the fragment shader output interface.

Additionally, the `Block<D>` trait enables types to be used as part of uniform inputs or vertex shader inputs.

These traits are generic over the domain `D`, which can be either `posh::Sl` (representing the shading language domain) or `posh::Gl` (representing the graphics library domain).
This duality allows for the same struct to serve both as part of a shader definition and as the actual input data for the shader.

To simplify the implementation of these traits for user-defined structs, `posh` provides derive macros.
These macros automate the generation of trait implementations, reducing the boilerplate and making it easier to define shaders and bind input data.
Importantly, `posh` avoids the use of procedural macros in other areas, allowing user code to remain familiar and maintain its readability as plain Rust.

#### Block Data

By implementing the `Block<D>` trait, user-defined types can be used in uniform buffers or in vertex buffers, i.e. it enables them to be used as part of a `UniformInterface<D>` or a `VsInterface<D>`.

`Block<D>` is generic in `D: BlockDom`, which represents a mapping for the core types that can be put into blocks. It defines core type representations as follows:
```rust
// Defined in `posh`:

pub trait BlockDom {
    type F32: Block<Self>;
    type I32: Block<Self>;
    type U32: Block<Self>;
    type Vec2: Block<Self>;
    // ...
}
```

The implementations of `BlockDom` for `posh::Gl` and `posh::Sl` simply map to their respective types:
```rust
// Implemented in `posh`:

impl BlockDom for Gl {
    type F32 = f32;
    type I32 = i32;
    type U32 = u32;
    type Vec2 = gl::Vec2;
    // ...
}

impl BlockDom for Sl {
    type F32 = sl::F32;
    type I32 = sl::I32;
    type U32 = sl::U32;
    type Vec2 = sl::Vec2;
    // ...
}
```

With these definitions, `Block<D>` is defined as follows:
```rust
// Defined in `posh`:

pub unsafe trait Block<D: BlockDom>: ToSl {
    type Gl: Block<Gl> + AsStd140 + Pod + ToSl<Output = Self::Sl>;
    type Sl: Block<Sl> + sl::Interpolant + ToSl<Output = Self::Sl>;
    // ... ignoring implementation details ...
}
```
The associated types `Block::Gl` and `Block::Sl` enable `posh` to map between the shading language representation and the graphics library representation of `Globals<D>`.
The bounds on the associated types specify the required traits that the struct needs to implement in the respective domains.

Let us revisit the `Globals<D>` type from the initial example:
```rust
#[derive(Clone, Copy, Block)]
struct Globals<D: BlockDom> {
    time: D::F32,
    size: D::Vec2,
}
```

The `Block` derive macro generates the necessary trait implementations for `Globals<Gl>` and `Globals<Sl>`:
```rust
// Generated by `derive(Block)`:

// ... impl `AsStd140`, `Pod`, and `ToSl` for `Globals<Gl>` ...
// ... impl `sl::Value` and `sl::Interpolant` for `Globals<Sl>` ...

unsafe impl Block<Gl> for Globals<Gl> {
    type Gl = Globals<Gl>;
    type Sl = Globals<Sl>;
    // ...
}

unsafe impl Block<Sl> for Globals<Sl> {
    type Gl = Globals<Gl>;
    type Sl = Globals<Sl>;
    // ...
}
```

Core types like `f32`, `i32`, `u32`, `gl::Vec2`, etc. already come with implementations of `Block<Gl>`.
Therefore, they can be used directly in uniform buffers or vertex buffers without requiring a custom type definition.

#### Uniform Interface

The uniform interface contains data that is constant on the level of individual draw calls.
It encompasses uniform blocks and texture samplers and is the first argument passed to shader functions.

Similar to other interface traits, `UniformInterface<D>` has a corresponding domain trait that provides a mapping for the types that can be used as uniform inputs:
```rust
// Defined in `posh`:

pub trait UniformInterfaceDom: Copy {
    type Block<B: Block<Sl, Sl = B>>: UniformInterface<Self>;
    type ColorSampler2d<S: sl::ColorSample>: UniformInterface<Self>;
    // ...
}
```

The implementation of `UniformInterfaceDom` for `posh::Gl` provides uniform binding types, while `posh::Sl` provides types for accessing uniforms in shader definitions:
```rust
// Implemented in `posh`:

impl UniformInterfaceDom for Gl {
    type Block<B: Block<Sl, Sl = B>> = gl::UniformBufferBinding<B>;
    type ColorSampler2d<S: sl::ColorSample> = gl::ColorSampler2d<S>;
    // ...
}

impl UniformInterfaceDom for Sl {
    type Block<B: Block<Sl, Sl = B>> = B;
    type ColorSampler2d<S: sl::ColorSample> = sl::ColorSampler2d<S>;
    // ...
}
```

The definition of `UniformInterface<D>` is straightforward.
Like `Block<D>` and other interface traits, it provides associated types `Gl` and `Sl` for mapping the implementing struct between the two domains.
```rust
// Defined in `posh`:

pub unsafe trait UniformInterface<D: UniformInterfaceDom>: Sized {
    type Gl: UniformInterface<Gl>;
    type Sl: UniformInterface<Sl>;
    // ... ignoring implementation details ...
}
```

Recalling `SceneUniforms<D>` from the shadow mapping example shown earlier, we used a derive macro to implement `UniformInterface<D>` for a custom type.
```rust
#[derive(Clone, UniformInterface)]
struct SceneUniforms<D: UniformInterfaceDom> {
    camera: D::Block<Camera<Sl>>,
    light: D::Block<Light<Sl>>,
    light_depth_map: D::ComparisonSampler2d,
}
```

As a result of implementing `UniformInterface<D>`, we can use `SceneUniforms<Sl>` as uniform shader input (i.e., the first argument in shader functions) and `SceneUniforms<Gl>` to provide uniform bindings for draw calls.

Types that implement `Block<D>` can be used directly as `UniformInterface<D>` without the need to define a custom type that contains the block.
This is achieved through blanket implementations provided by `posh`:
```rust
// Implemented in `posh`:

unsafe impl<B: Block<Sl, Sl = B>> UniformInterface<Gl>
    for gl::UniformBufferBinding<U> 
{
    type Gl = gl::UniformBufferBinding<B>;
    type Sl = B;
    // ...
}

unsafe impl<B: Block<Sl, Sl = B>> UniformInterface<Sl> for B {
    type Gl = gl::UniformBufferBinding<B>;
    type Sl = B;
    // ...
}
```
The same applies to sampler types.

In practice, the vertex shader often requires a different subset of uniform inputs than the fragment shader.
However, `gl::Program<U, ...>` specifies only a single type `U: UniformInterface<Sl>`.
To simplify the definition of shader functions, the uniform types required by the fragment shader and the vertex shader can be unified into a single uniform type using the `UniformUnion` trait.

The `UniformUnion` trait allows for the following unifications (assuming `U, U1, U2: UniformInterface<Sl>`):
1. `U + () -> U` if `U ≠ ()`.
2. `() + U -> U` if `U ≠ ()`.
3. `() + () -> ()`.
4. `U + U -> U` if `U ≠ ()`.
5. `U1 + U2 -> (U1, U2)` if `U1 ≠ ()` and `U2 ≠ ()`.
6. `U1 + (U1, U2) -> (U1, U2)` if `U1 ≠ ()`.
7. `(U1, U2) + U1 -> (U1, U2)` if `U1 ≠ ()`.

For example, using unification #5, we can receive a uniform block containing a projection matrix in a vertex shader and a uniform sampler in a fragment shader, and compile these two shaders into a program that takes the pair of the two individual uniform inputs as follows:
```rust
fn vertex_shader(projection: sl::Mat4, vertex: sl::Vec4) -> sl::Vec4 {
    todo!()
}

fn fragment_shader(sampler: sl::ColorSampler2d, interpolant: ()) -> sl::Vec4 {
    todo!()
}

// The uniform input types of the two shader functions are unified to a pair.
let program: gl::Program<(sl::Mat4, sl::ColorSampler2d)> = gl.create_program(
    vertex_shader,
    fragment_shader,
);
```  

#### Vertex Shader Interface

In most cases, defining a custom vertex struct containing attributes (such as position, color, etc.), and deriving `Block<D>` for it is sufficient.
Such vertex data can be stored in a vertex buffer in the graphics library, and individual vertex values can be read from it in the shading language.

However, in certain scenarios like instanced rendering, it becomes necessary to bind vertex data from multiple vertex buffers.
To support this, posh allows users to implement `VsInterface<D>` for their own structs.

The corresponding domain trait is defined as follows:
```rust
// Defined in `posh`:

pub trait VsInterfaceDom: BlockDom {
    type Block<B: Block<Sl>>: VertexField<Self>;
}
```

Its implementation for `posh::Gl` provides bindings of vertex buffers, while `posh::Sl` allows reading from an individual vertex input:
```rust
// Implemented in `posh`:

impl VsInterfaceDom for Gl {
    type Block<B: Block<Sl>> = gl::VertexBufferBinding<B>;
}

impl VsInterfaceDom for Sl {
    type Block<B: Block<Sl>> = B;
}
```

Based on this, the interface trait is defined as follows, following the pattern of other interface traits:
```rust
// Defined in `posh`:

pub unsafe trait VsInterface<D: VsInterfaceDom> {
    type Gl: VsInterface<Gl>;
    type Sl: VsInterface<Sl>;
    // ...
}
```

In the [instancing example](https://github.com/leod/posh/blob/main/examples/instancing.rs) in the repository, a custom struct `VsInput<D>` is defined, which contains both per-instance input (a custom block type, `Instance<D>`) and per-vertex input (a position vector).
These inputs can then be accessed in the vertex shader to obtain their current values:
```rust
#[derive(Clone, Copy, Block)]
#[repr(C)]
struct Instance<D: BlockDom> {
    model_to_view: D::Mat4,
    color: D::Vec3,
}

#[derive(Copy, Clone, VsInterface)]
struct VsInput<D: VsInterfaceDom> {
    instance: D::Block<Instance<Sl>>,
    model_pos: D::Block<sl::Vec3>,
}

fn vertex_shader(
    camera: Camera<Sl>,
    vertex: VsInput<Sl>,
) -> sl::VsOutput<sl::Vec3> {
    sl::VsOutput {
        clip_position: camera.view_to_screen
            * camera.world_to_view
            * vertex.instance.model_to_view
            * vertex.model_pos.extend(1.0),
        interpolant: vertex.instance.color,
    }
}
```

On the host side, individual vertex buffer bindings need to be provided for instance data and vertex data.
To mark a vertex buffer binding as per-instance data, the `with_instancing()` method is used.
```rust
let program: gl::Program<Camera<Sl>, VsInput<Sl>> = gl.create_program(
    vertex_shader,
    fragment_shader,
)?;

// Ignoring buffer creation...
let instances: gl::VertexBuffer<Instance<Gl>> = todo!();
let teapot: gl::VertexBuffer<gl::Vec3> = todo!();

program
    // ... other bindings ...
    .draw(
        gl::VertexSpec::new(gl::PrimitiveMode::Triangles)
            .with_vertex_data(VsInput {
                instance: instances.as_binding().with_instancing(),
                model_pos: teapot.as_binding(),
            }),
    )?;
```

#### Fragment Shader Interface

Finally, let us take a look at custom fragment shader interfaces.
So far, the examples have computed a single `sl::Vec4` color in their fragment shaders.
However, in some cases, it may be necessary to compute multiple colors that are written into individual framebuffer attachments on the host side.
To achieve this, we need to implement `FsInterface<D>` for a custom struct.

The corresponding domain trait is defined as follows, where `sl::ColorSample` is a trait implemented for core types representing a single sample of the framebuffer in the shading language (e.g., `sl::F32` or `sl::Vec4`):
```rust
// Defined in `posh`:

pub trait FsInterfaceDom: Copy {
    type ColorAttachment<S: sl::ColorSample>: FsInterface<Self>;
}
```

Its implementation for `posh::Gl` provides framebuffer attachments, while `posh::Sl` provides the type that contains a single output value to be written to the framebuffer in the shading language.
```rust
// Implemented in `posh`:

#[sealed]
impl FsInterfaceDom for Gl {
    type ColorAttachment<S: sl::ColorSample> = gl::ColorAttachment<S>;
}

#[sealed]
impl FsInterfaceDom for Sl {
    type ColorAttachment<S: sl::ColorSample> = S;
}
```

The interface trait follows the same pattern as other interface traits we have seen:
```rust
// Defined in `posh`:

pub unsafe trait FsInterface<D: FsInterfaceDom> {
    type Gl: FsInterface<Gl>;
    type Sl: FsInterface<Sl> + sl::Interpolant + ToSl<Output = Self::Sl>;
    // ...
}
```

A typical use case for a custom fragment shader interface is deferred shading, where the scene is first rendered to screen space textures containing information such as world position, world normal, or color.
In the [deferred example](https://github.com/leod/posh/blob/main/examples/deferred.rs) in the repository, `FsInterface<D>` is derived for a custom struct that contains three output fields:
```rust
#[derive(Clone, Copy, FsInterface)]
pub struct SceneAttachments<D: FsInterfaceDom> {
    albedo: D::ColorAttachment<sl::Vec3>,
    world_normal: D::ColorAttachment<sl::Vec3>,
    world_pos: D::ColorAttachment<sl::Vec3>,
}
```
On the host side, the struct `SceneAttachments<Gl>` contains attachments of three individual textures that will be rendered into.
On the shading language side, the struct `SceneAttachments<Sl>` contains expressions in the shading language for the output values of a single fragment shader invocation.

In compiled programs, the shader signature type `F: FsInterface<Sl>` is captured as the third generic argument to `gl::Program<U, V, F>`.
By default, it is set to `sl::Vec4`, which is the fragment shader output type compatible with the default framebuffer.

### The Shading Language

The shading language `posh::sl` provides a set of types and primitives that are designed to enable the definition of shaders in readable code embedded in Rust. 
By embedding shaders in Rust, it becomes trivial to capture their type signatures.
This is what makes it possible to integrate typed shaders with the graphics library `posh::gl` based on the shader interface traits defined in the previous section.

This section takes a closer look at the types and primitives provided by `posh::sl`.
It also shows how these types enable transpiling user-defined shader functions to valid GLSL code at runtime.

#### Types

The shading language provides a variety of types that correspond to GLSL types.
Here are the available core types:
- Scalar types `sl::F32`, `sl::I32`, `sl::U32`, `sl::Bool`.
- Floating-point vector types: `sl::Vec2`, `sl::Vec3`, and `sl::Vec4`.
- Integer vector types: `sl::IVec2`, `sl::IVec3`, and `sl::IVec4`.
- Unsigned integer vector types: `sl::UVec2`, `sl::UVec3`, and `sl::UVec4`.
- Boolean vector types: `sl::BVec2`, `sl::BVec3`, and `sl::BVec4`.
- Floating-point matrix types: `sl::Mat2`, `sl::Mat3`, and `sl::Mat4`.

The API for vector and matrix types largely imitates [glam](https://github.com/bitshifter/glam-rs).
In some places, methods have been modified to better match GLSL.

Constant values can be converted to `posh::sl` with the `sl::ToSl` trait, which provides the `to_sl()` method.
For example, you can convert a `f32` to an `sl::F32` type as follows:
```rust
use posh::ToSl;

let c: sl::F32 = 5.0f32.to_sl();
```

The shading language also supports pairs of arbitrary types.
However, larger tuples are yet to be implemented.
Constant-size arrays are supported through `sl::Array<V, N>`, where `V` is the inner type and `const N: usize` is the size of the array.

In addition to these basic types, `posh::sl` provides sampler types such as `sl::ColorSampler2d<S>` and `sl::ComparisonSampler2d`.
However, some sampler types, like cube maps, are yet to be implemented.

#### Values

Internally, all types that occur in `posh::sl` expressions implement the trait `sl::Object`, which allows converting the value into an expression graph.
```rust
// Defined in `posh`:

pub trait Object {
    fn ty() -> Type;

    // Implementation detail:
    fn expr(&self) -> Rc<Expr>;

    // ...
}
```

The `Expr` type is an internal enum in `posh::sl` that represents an expression graph.
It is used for transpilation to GLSL.
It consists of different variants such as `Binary` for binary operations and `Field` for accessing struct fields.
```rust
// Defined in `posh`:

enum Expr {
    Binary {
        left: Rc<Expr>,
        op: BinaryOp,
        right: Rc<Expr>,
        ty: Type,
    },
    Field {
        base: Rc<Expr>,
        name: &'static str,
        ty: Type,
    },
    // ...
}
```

Most types in the shading language also implement the `Value` trait in addition to `Object`.
The `Value` trait indicates that a type can be stored in variables in the generated GLSL code.
Types implementing `Value` are called transparent.
This distinction is necessary due to a rule in GLSL, by which opaque types like `sampler2D` can not be stored in variables.
In order to implement `Value`, types need to provide a method for constructing `Self` from an `Expr`:
```rust
// Defined in `posh`:

pub trait Value: Object + Copy + ToSl<Output = Self> {
    // Implementation detail:
    fn from_expr(expr: Expr) -> Self;

    // ...
}
```
The core types provided by the shading language implement the `Value` and `Object` traits as appropriate.
User-defined structs can implement `Value` using the derive macro `derive(Value)`.

One important detail to notice is that `Value` has `Copy` as a base trait.
This design choice was made to make shader code look more natural, as values in GLSL are implicitly copyable.
However, this poses a problem, because the `Expr` type cannot implement `Copy` due to its fields of type `Rc<Expr>`.
To work around this, posh uses a hack where `Rc<Expr>` instances are stored in a global `thread_local` registry of type `BTreeMap<usize, Rc<Expr>>`.
Values in the shading language then store the key for looking up the `Rc<Expr>` from this map with a wrapper type called `Trace`.
For example, the scalar floating-point type `sl::F32` is defined like this:
```rust
// Defined in `posh`:

#[derive(Debug, Copy, Clone)]
pub struct F32(Trace);

impl Object for F32 {
    fn ty() -> Type {
        Type::BuiltIn(BuiltInType::F32)
    }

    fn expr(&self) -> Rc<Expr> {
        // Look up `Rc<Expr>` from the global registry using our `Trace` key.
        self.0.expr()
    }
}

impl Value for F32 {
    fn from_expr(expr: Expr) -> Self {
        // Make a new entry in the global registry and obtain a `Trace` key.
        Self(Trace::new(expr))
    }
}
```

This approach allows values to be `Copy`, making shader code more intuitive to write.
However, it has some downsides, such as the question of invalidation of entries in the registry, which is currently not addressed in the implementation.

#### Primitives

The shading language `posh::sl` provides a range of primitive functions that allow the creation of complex expressions out of simpler ones.

For scalar types, vector types, and matrix types, the arithmetic operators are overloaded.
This enables, for example, vector-vector, vector-scalar, matrix-matrix, or matrix-vector operations.
These operators take the expressions of their inputs, represented as `Rc<Expr>`, and combine them into a new expression that describes the computation.
As an example, the addition operator is implemented for the scalar floating-point type `sl::F32` as follows:
```rust
// Implemented in `posh`:

impl std::ops::Add<sl::F32> for sl::F32 {
    type Output = Self;

    fn add(self, right: sl::F32) -> Self {
        F32::from_expr(Expr::Binary {
            ty: Self::ty(),
            left: self.expr(),
            op: BinaryOp::Add,
            right: right.expr(),
        })
    }
}
```
Other operators provided by `posh::sl` follow the same pattern, utilizing the expressions of their constituents to construct a new expression.

In addition to overloaded operators, there are functions and methods for additional primitives that cannot be defined through operator overloading in Rust:
- `sl::and` and `sl::or`: Binary boolean operations on `sl::Bool`.
- `sl::all` and `sl::any`: Boolean operations on iterators of `sl::Bool`.
- `sl::Value::eq`: Checks equality between two values.
- Methods like `sl::I32::lt` (less than) for comparing values.

One important primitive function is `sl::branch(condition, yes, no)`, which represents a conditional expression.
If the `condition` is true, the `yes` value is returned; otherwise, the `no` is returned.
In the implementation of `posh::sl`, transpilation of this function requires special care to ensure correct scoping of variables.

It is worth noting that all of the provided primitives in `posh::sl` are functional, meaning they are stateless and do not have side effects.
As of now, `posh::sl` does not support mutable values, and there are no immediate plans to introduce them.
However, there are plans to provide a primitive function like `sl::iterate` to support loop constructs in the future.

#### Transpilation

### The Graphics Library