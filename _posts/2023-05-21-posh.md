---
layout: post
title:  "Introducing `posh`: Type-Safe Graphics Programming in Rust"
date:   2023-05-21 17:00:00 +0100
categories: rust gamedev posh
---

This post introduces [`posh`](https://github.com/leod/posh), an experimental Rust graphics library aimed at enhancing the type-safety, composability, and overall experience of graphics programming.
It covers the fundamental concepts of `posh`, showcases examples, and delves into the internal workings of the library.

`posh` consists of two closely integrated modules: `posh::gl`, a graphics library responsible for uploading data to the GPU and executing draw calls, and `posh::sl`, a functional shading language embedded within Rust.
The tight integration between these modules enables static verification, ensuring that the data provided in draw calls aligns with the shader's signature.

The typical structure of `posh` code follows this pattern:
```rust
use posh::{gl, sl};

// ... define custom types U, V, W, and F ...

fn vertex_shader(uniform: U, vertex: V) -> sl::VsOutput<W> {
    // ... compute `sl::VsOutput { clip_position, interpolant }` ...
}

fn fragment_shader(uniform: U, interpolant: W) -> F {
    // ... compute F ...
}

let program: gl::Program<U, V, F> = gl.create_program(
    vertex_shader,
    fragment_shader,
)?;

program
    .with_uniforms(/* uniform bindings matching U */)
    .with_framebuffer(/* framebuffer matching F */)
    .with_settings(/* draw settings */)
    .draw(/* vertex specification matching V */)?;
```
Shader functions are written as Rust code that interacts with types from `posh::sl`, thereby leveraging the benefits of Rust's type checking and composability.
Internally, at runtime, shader functions generate expression trees that are translated to GLSL.
Since these are regular Rust functions, their signatures naturally become part of the `program`'s type, ensuring type safety when invoking the `draw` method.

The development of `posh` is motivated by the aim to simplify and streamline graphics programming.
Traditional graphics code often involves two distinct languages: the host language (e.g., Rust) and the shading language (e.g., GLSL).
This separation leads to boilerplate code on both sides and hampers the composition of functionality.
Moreover, draw calls, which act as a foreign function interface from host code to shader code, typically lack static type checks.
To address these challenges, `posh` provides a platform for defining shaders using a functional language embedded within Rust and integrates shader signatures with the graphics library.

## Current Status

Currently, `posh` targets subsets of [OpenGL ES 3.0](https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf) and [GLSL ES 3.0](https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf) to narrow down the initial scope of the project. However, we are considering to transition to [wgpu](https://github.com/gfx-rs/wgpu) in the long run.

It is important to note that `posh` is still in its early stages and may require several revisions to reach stabilization.
We welcome contributions to the design and implementation of `posh`. Feel free to explore `posh`'s [repository](https://github.com/leod/posh), including its [examples](https://github.com/leod/posh/tree/main/examples) and [open issues](https://github.com/leod/posh/issues), to get an idea of where we currently stand.
Please be aware that there is no release available on [crates.io](https://crates.io/) at this time.

## Hello, Triangle!

![Example: A triangle](/assets/hello_triangle.png)

To get started, let us draw a triangle whose position and shading depend on the current time.
You can find the complete source code for this example in the [repository](https://github.com/leod/posh/blob/main/examples/hello_triangle.rs).

When writing `posh` code, there are three basic steps to follow.

### 1) Define Shader Interface Types

Shaders typically require access to uniform inputs provided by the host.
In this example, we will need the current time and the desired size of the triangle.
To achieve this, we create a struct and derive `Block` for it, which allows us to use it as a uniform block.
```rust
use posh::{Block, BlockDom};

#[derive(Clone, Copy, Block)]
struct Globals<D: BlockDom> {
    time: D::F32,
    size: D::Vec2,
}
```

Shader interface types like `Globals<D>` are generic in the domain `D`.
There are two domains: `posh::Gl`, which provides data and bindings for draw calls, and `posh::Sl`, which provides types used in shader definitions.
The concept of domains connects the two sides of graphics programming.
We'll use `Globals<Gl>` to describe data to be stored in buffers on the GPU and `Globals<Sl>` to access inputs in our shader code.

### 2) Write Shader Code

Next, we will write shader code using `posh::sl`.
We will define the vertex shader and the fragment shader functions to specify where and how the triangle should be drawn.

In `posh::sl`, shader functions have two arguments.
The first argument is the uniform input, while the second argument is the current input of the shader (vertex input for the vertex shader and interpolant input for the fragment shader).

In this example, the vertex shader receives `Globals<Sl>` as uniform input, and a two-dimensional position as vertex input.
The shader computes the `clip_position` output (equivalent to `gl_Position` in GLSL) along with an `interpolant`, which is interpolated and passed on to the fragment shader by the GPU:
```rust
use posh::{sl, Sl};

fn vertex_shader(
    globals: Globals<Sl>,
    vertex: sl::Vec2,
) -> sl::VsOutput<sl::Vec2> {
    let position = sl::Vec2::from_angle(globals.time)
        .rotate(vertex * globals.size);

    sl::VsOutput {
        clip_position: sl::vec4(position.x, position.y, 0.0, 1.0),
        interpolant: vertex,
    }
}

```

The fragment shader uses the `interpolant` to compute a time-dependent color for each fragment:
```rust
fn fragment_shader(globals: Globals<Sl>, interpolant: sl::Vec2) -> sl::Vec4 {
    let rg = (interpolant + globals.time).cos().powf(2.0);

    sl::vec4(rg.x, rg.y, 0.5, 1.0)
}
```

Internally, types like `Globals<Sl>` or `sl::Vec2` represent expression trees that can be transformed to GLSL.
For instance, the variables `globals` and `interpolant` are leaf nodes representing inputs of the fragment shader.
Expressions like `interpolant + globals.time` are nodes in the expression tree that describe how their values are computed.
This makes it possible to transpile `vertex_shader` and `fragment_shader` as a whole to GLSL without requiring macro magic.

### 3) Write Host Code

Now, we will write host code using `posh::gl`.
We will set up buffer data on the GPU and then perform a draw call with the shader that we have defined above.
For the purpose of this example, we will assume that we already have a variable `gl: gl::Context` available (ignoring context creation).

First, we compile our two shader functions into a program.
Note that the program's type carries the shader's signature:
```rust
use posh::gl;

let program: gl::Program<Globals<Sl>, sl::Vec2> = gl.create_program(
    vertex_shader,
    fragment_shader,
)?;
```

Next, we set up buffers on the GPU to hold data to be supplied to the shader.
The types of `globals` and `vertices` align with the signature of the `program`:
```rust
let globals: gl::UniformBuffer<Globals<Gl>> = gl.create_uniform_buffer(
    Globals {
        time: 42.0,
        size: [1.0, 1.0].into(),
    },
    gl::BufferUsage::StreamDraw,
)?;
let vertices: gl::VertexBuffer<gl::Vec2> = gl.create_vertex_buffer(
    &[
        [0.0f32, 1.0].into(),
        [-0.5, -0.5].into(),
        [0.5, -0.5].into(),
    ],
    gl::BufferUsage::StreamDraw,
)?;
```

Finally, we perform a draw call using a method of `program`.
This requires us to supply bindings for uniform inputs and vertex inputs, along with various draw settings.
```rust
program
    .with_uniforms(globals.as_binding())
    .with_settings(
        gl::DrawSettings::default()
            .with_clear_color([0.1, 0.2, 0.3, 1.0])
    )
    .draw(vertices.as_vertex_spec(gl::PrimitiveMode::Triangles))?;
```

The draw call is where everything comes together in `posh`.
It takes our compiled shader, supplies GPU buffer bindings, and draws something to a framebuffer (in this instance, the default framebuffer).
The `draw` method benefits from static type-checking, allowing the Rust compiler to help ensure that the data we provide matches the expected types in the shader.
This provides an additional level of correctness to our graphics programming workflow.

## A More Complex Example: Shadow Mapping

![Example: Shadow Mapping](/assets/shadow_map.png)

In this section, we will a explore a more complex example.
We will look at a way to render a scene with [shadow mapping](https://en.wikipedia.org/wiki/Shadow_mapping) (assuming that the shadow map has already been created).
You can find the complete source code for this example in the [repository](https://github.com/leod/posh/blob/main/examples/shadow_map.rs).

Without delving into details of how shadow mapping works, let us again follow the three basic steps of writing `posh` code.

### 1) Define Shader Interface Types

First, we define a custom vertex type, `SceneVertex<D>`, to hold world-space information of the scene to be drawn.
We also define the `Camera<D>` and `Light<D>` types for the view camera and the light source.
```rust
use posh::{Block, BlockDom};

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct SceneVertex<D: BlockDom> {
    world_pos: D::Vec3,
    world_normal: D::Vec3,
    color: D::Vec3,
}

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct Camera<D: BlockDom> {
    world_to_eye: D::Mat4,
    eye_to_clip: D::Mat4,
}

#[derive(Clone, Copy, Block)]
#[repr(C)]
struct Light<D: BlockDom> {
    camera: Camera<D>,
    world_pos: D::Vec3,
    color: D::Vec3,
    ambient: D::Vec3,
}
```

Lastly, we define the `SceneUniforms<D>` type, which encapsulates the uniform inputs required by our shaders, including the depth map sampler.

```rust
use posh::{UniformInterface, UniformInterfaceDom};

#[derive(Clone, UniformInterface)]
struct SceneUniforms<D: UniformInterfaceDom> {
    camera: D::Block<Camera<Sl>>,
    light: D::Block<Light<Sl>>,
    light_depth_map: D::ComparisonSampler2d,
}
```

Any type that implements `UniformInterface` can be used as uniform input for shaders.
Similar to `Block` declarations, `UniformInterface` declarations are generic in the domain `D`.
In this example, `SceneUniforms<Gl>` contains bindings of uniform buffers and samplers, while `SceneUniforms<Sl>` provides the inputs for shader definitions.

### 2) Write Shader Code

Next, let us define an `Interpolant` struct, which connects the vertex and fragment shaders.
The fragment shader requires access to the interpolated input vertex and the input vertex's position in the light source's clip space.
```rust
use posh::{sl, Sl};

#[derive(Clone, Copy, sl::Value, sl::Interpolant)]
struct Interpolant {
    vertex: SceneVertex<Sl>,
    light_clip_pos: sl::Vec4,
}
```

Now, we can implement our vertex shader, using a utility function for `Camera<Sl>`:
```rust
impl Camera<Sl> {
    fn world_to_clip(self, world_pos: sl::Vec3) -> sl::Vec4 {
        self.eye_to_clip * self.world_to_eye * world_pos.extend(1.0)
    }
}

fn vertex_shader(
    SceneUniforms { light, camera, .. }: SceneUniforms<Sl>,
    vertex: SceneVertex<Sl>,
) -> sl::VsOutput<Interpolant> {
    // Slightly extrude along the normal to reduce shadow artifacts.
    const EXTRUDE: f32 = 0.1;
    let light_clip_pos = light
        .camera
        .world_to_clip(vertex.world_pos + vertex.world_normal * EXTRUDE);

    sl::VsOutput {
        clip_position: camera.world_to_clip(vertex.world_pos),
        interpolant: Interpolant { vertex, light_clip_pos },
    }
}
```

The `Interpolant` is fed from the vertex shader to the fragment shader, which uses it to sample the shadow map and shade the fragment.

```rust
fn sample_shadow(
    light_depth_map: sl::ComparisonSampler2d,
    light_clip_pos: sl::Vec4,
) -> sl::F32 {
    let ndc = light_clip_pos.xyz() / light_clip_pos.w;
    let uvw = ndc * 0.5 + 0.5;

    // Fall back to zero if the UV coordinates would be clamped.
    let clamp = sl::any([
        uvw.x.lt(0.0),
        uvw.x.gt(1.0),
        uvw.y.lt(0.0),
        uvw.y.gt(1.0),
    ]);

    sl::branch(
        clamp,
        0.0,
        light_depth_map.sample_compare(uvw.xy(), uvw.z),
    )
}

fn fragment_shader(
    SceneUniforms { light, light_depth_map, ..  }: SceneUniforms<Sl>,
    Interpolant { vertex, light_clip_pos }: Interpolant,
) -> sl::Vec4 {
    let light_dir = (light.world_pos - vertex.world_pos).normalize();
    let diffuse = light.color * vertex.world_normal.dot(light_dir).max(0.0);
    let shadow = sample_shadow(light_depth_map, light_clip_pos);
    let color = (light.ambient + shadow * diffuse) * vertex.color;

    color.extend(1.0)
}
```

### 3) Write Host Code

On the host side, we compile the two shader functions into a program:
```rust
use posh::gl;

let program: gl::Program<SceneUniforms<Sl>, SceneVertex<Sl>> =
    gl.create_program(vertex_shader, fragment_shader)?;
```

We also need to set up several GPU buffers.
Ignoring the contents of the buffers, we have the following objects:
```rust
let camera_buffer: gl::UniformBuffer<Camera<Gl>> = todo!();
let light_buffer: gl::UniformBuffer<Light<Gl>> = todo!();
let light_depth_map: gl::DepthTexture2d = todo!();
let scene_vertices: gl::VertexBuffer<SceneVertex<Gl>> = todo!();
let scene_elements: gl::ElementBuffer = todo!();
```

Finally, we can render the scene with shadow mapping:
```rust
scene_program
    .with_uniforms(SceneUniforms {
        camera: camera_buffer.as_binding(),
        light: light_buffer.as_binding(),
        light_depth_map: light_depth_map.as_comparison_sampler(
            gl::Sampler2dSettings::linear(),
            gl::Comparison::Less,
        ),
    })
    .with_settings(
        gl::DrawSettings::default()
            .with_clear_color([1.0, 1.0, 1.0, 1.0].into())
            .with_clear_depth(2.0)
            .with_depth_test(gl::Comparison::Less)
            .with_cull_face(gl::CullFace::Back)
    )
    .draw(
        scene_vertices
            .as_vertex_spec(gl::PrimitiveMode::Triangles)
            .with_element_data(scene_elements.as_binding())
    )?;
```

Once again, the draw call serves as the point where all the components come together in a type-safe manner.

## Related Work

The development of `posh` has drawn inspiration from several amazing existing projects.

[`rust-gpu`](https://github.com/EmbarkStudios/rust-gpu) enables Rust to be used as a first-class language for writing shaders by implementing a `rustc` backend that generates [SPIR-V](https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation).
While `posh` shares the goal of enhancing shader development, it takes a different approach.
Instead of treating Rust as a primary shader language, `posh` employs a functional language embedded within Rust to implement shaders.
Additionally, while `rust-gpu` primarily focuses on shader code, `posh` places emphasis on achieving a type-safe integration between shader code and host code.

[Shades](https://github.com/phaazon/shades) provides an embedded domain-specific language for shaders, similar to `posh`.
However, Shades is designed as a general-purpose library without specific ties to a target shading language or graphics library.
In contrast, `posh` intentionally narrows its scope to a functional subset of GLSL and aligns itselfs with a subset of OpenGL.
We hope that this limitation will allow us to iterate quickly and focus on the integration of shader code with host code.
However, as a result, `posh` is less powerful than Shades in many ways.

[glium](https://github.com/glium/glium) is an OpenGL wrapper that demonstrates that OpenGL can be used elegantly in Rust.
In glium, the dependencies of a draw call are consolidated into a single method.
`posh` builds upon this concept by introducing typed shader signatures.

## How Does it Work?

### Shader Interfaces

`posh` uses Rust's powerful trait system for binding the graphics library `posh::gl` to the shading language `posh::sl`.
It provides derive macros to define shader interface types such as vertex data, uniform data, or fragment shader outputs.
While there is a fair bit of magic in these traits and derive macros, `posh` avoids procedural macros in other places, so that user code can be transparently read as plain old Rust.

### The Shading Language

#### Types

The shading language provides a variety of types that correspond to GLSL types:
- Scalar types `sl::F32`, `sl::I32`, `sl::U32`, `sl::Bool`.
- Floating-point vector types: `sl::Vec2`, `sl::Vec3`, and `sl::Vec4`.
- Integer vector types: `sl::IVec2`, `sl::IVec3`, and `sl::IVec4`.
- Unsigned integer vector types: `sl::UVec2`, `sl::UVec3`, and `sl::UVec4`.
- Boolean vector types: `sl::BVec2`, `sl::BVec3`, and `sl::BVec4`.
- Floating-point matrix types: `sl::Mat2`, `sl::Mat3`, and `sl::Mat4`.

The API for vector and matrix types largely imitates [glam](https://github.com/bitshifter/glam-rs).
In some places, methods have been modified to better match GLSL.

Constant values can be converted to `posh::sl` with `ToSl`:
```rust
use posh::ToSl;

let c: sl::F32 = 5.0f32.to_sl();
```

The shading language additionally provides the sampler types `sl::ColorSampler2d<S>` and `sl::ComparisonSampler2d`.
More sampler types (e.g., cube maps) have yet to be implemented.

#### Primitives

#### Transpilation

### The Graphics Library

## Discussion
